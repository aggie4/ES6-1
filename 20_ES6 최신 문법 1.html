<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>ES6 최신 문법 1</title>
    </head>
    <body>
        <h1>ES6 Javascript 최신 문법</h1>
        <textarea cols="150" rows="10">
            
            1. 모던 자바스크립트, 모던 신텍스, 최신 문법 등으로 이야기 한다.
            2. ES란 ? ECMAScript의 약자이고, 자바스키립트의 표준, 규격을 나타내는 용어이다. 자동차로 친다면 모델명정도?
            3. 모든 언어는 업데이트를 한다. 처음부터 완벽하게 만들어서 나오지 않기 때문이다. 그 중에 가장 핫했던, 업데이트가 ES6이다.
            4. 뒤에 숫자는 버전을 나타내는 것이더.. ES4 → ES5 → ES6 (ES5는 2009년, ES6는 2015년 출시 되었다.)
            5. 문법을 나열하면 다음과 같다.
                - 템플릿 리터럴
                    1. 사용법은 백틱으로 사용된다.
                    2. `ES6 최신문법을 사용하는 나는 ${myName}이다.`

                        ES5
                        var str1 = ', ';
                        var str2 = 'World!';
                        var str3 = 'Hello' + str1 + str2;

                        ES6
                        let str1 = ', ';
                        let str2 = 'World!';
                        let str3 = `Hello ${str1} ${str2}`;

                - 객체 리터럴
                    1. 이전 문법보다 훨씬 간격해진 코드로 객체를 선언할 수 있다.
                    2. 메소드에 더이상 클론(;) 이나 function을 붙이지 않아도 된다.
                    3. 함수명이 겹치는 경우에는 한번만 쓸 수 있다.
                    4. 객체의 프로퍼티를 동적으로 생성하려면 객체 리터럴 바깥에서 [text + 1]과 같이 선언했어야 했었다.
                    5. ES6 부터는 객체 안에서 바로 속성으로 사용할 수 있게 되었다.

                        const myFn = function () {
                            console.log('myFn');
                        };
                        const text = 'TEXT';
                        const obj = {
                            inside() {
                                console.log('객체 안에 바로 함수를 선언');
                            },
                            myFn,
                            [text + 1] : '프론트엔드'
                        };
                        obj.inside();               // 출력값 : 객체 안에 바로 함수를 선언
                        obj.myFn();                 // 출력값 : myFn
                        console.log(obj.TEXT1)      // 출력값 : 프론트엔드

                - 화살표 함수 (에로수 펑션)
                    1. 함수 표현식을 화살표 함수로 표현 할 수 있다.
                    2. 화살표 함수가 추가되어 함수를 간결하게 나타낼 수 있게 되어 가동석 및 유지 보수성이 올라갔다.
                    3. 만약 함수의 본문인 return만 있는 경우 화살표 함수는 return과 {}를 생략할 수 있다. 단, 둘이 같이 생략해야 한다.
                    4. return문에서 소괄호는 사용가능하다.

                        ES5
                        function plusFn (a, b) {
                            return a + b;
                        };

                        ES6
                        // 함수 표현식 - 화살표 함수, 에로우 펑션
                        const plusFn = (a, b)=> {
                            return a + b
                        };
                        // 함수 표현식 - 화살표 함수 (생략형) < return만 있는 경우 {} 생략 가능 단, 둘 다 같이 생략
                        const plusFn = (a, b)=> a + b;
                        
                        const 함수이름 = () => {} 

                    5. 일반 함수에는 있지만 화살표 함수에는 없는것이 있다. 그것이 바로 this 키워드 이다.
                        - this란? this 는 나, 본인, 자기자신, 지금 이거!라는 뜻
                        - this를 사용하게 되면 => 에로우펑션 보단 일반 function를 사용하는 것이 좋다

                        // this 예제
                        let age = 30;
                        let person = {
                            name : '김성진',
                            age : 20,
                            getInfo : function () {
                                console.log(age)
                            }
                        }
                        person.getInfo()

                        //전역변수 age 말고 객체 안에 있는 age 부러들이기 위해 this를 사용했다
                        let age = 30;
                        let person = {
                            name : '김성진',
                            age : 20,
                            getInfo : function () {
                                console.log(this.age)
                            }
                        }
                        person.getInfo()

                        // 객체 안에 함수를 에로우 펑션으로 바꾸면??
                        let age = 30;
                        let person = {
                            name : '김성진',
                            age : 20,
                            getInfo : () => {
                                console.log(this.age)       // 언디파인디드 라는 꼴보기 싫은 문구가 콘솔에 나타남
                            }
                        }
                        person.getInfo()

                    6. 에로우 펑션에서 this는 나를 불러준 함수 또는 객체 또는 기타등등이 포함되어있는 가장 최 상위 공간을 this로 인식한다.
                        let age = 30;
                        let person = {
                            name : '김성진',
                            age : 20,
                            getInfo : () => {
                                console.log(this)
                            }
                        }
                        person.getInfo()
                    7. 위의 함수 안에 this 생성 방식을 전문용어(?)로 렉시컬 스코프 (lexical scope)라고 한다.
                    8. 함수가 포함된 영역을 가르키는 상황이 필요하다면 일반 함수를 사용하고, 그게 아니라면 화살표 함수를 사용하면 된다.

                - 변수 선언 키워드
                    1. 기존에 사용되던 변수 선언의 키워드는 var 이다.
                    2. 추가된 키워드가 let과 const 이다.
                    3. 블로 스코프를 가지고 재선언 불가 재할당 가능한 let 변수 선언 키워드
                    4. 상수 선언 키워드 const가 추가 되었다.
                    5. 기존의 var 키워드만 있었을 때 보다 예측 가능한 코드를 작성 할 수 있게 되었다.

                - 모듈 (Module)
                    1. 모듈이란 재사용하기 위한 코드의 조각을 뜻한다.
                    2. 세부사항은 캡슐화 시키고, API 부분만 외부에 노출시킨 코드이다.
                    3. type에 module를 추가시키고, 확장자를 mjs로 변경해서 사용한다.
                    4. 모듈은 모듈 스코프를 가지며, import와 export 키워드를 이용하게 사용하게 된다.
                        <script type="module" src="lib.mjs"></script>

                - 구조 분해 할당
                    1. 구조 분해 할당이란 펼치다 라는 뜻이다.
                    2. 객체나 배열에서 사용한다.
                    3. 값을 해체한 후, 개별 값을 변수에 새로 할당하는 과정을 이야기한다.

                        // 배열에서 Spread 사용
                        const arr = [1, 2, 3];
                        const [one, two, three] = arr
                        one     // 1
                        two     // 2
                        three   // 3

                        // 객체에서 Spread 사용
                        const obj = {
                            firstName : '프론트',
                            lastName : '엔드'
                        };
                        const {firstName, lastName} = obj;
                        firstName :     // 프론트
                        lastName :      // 엔드

                    4. 객체 초기화 방법
                        let name = "SungJin"
                        let age = 20
                        위의 데이터들을 가지고 객체를 만든다면 다음과 같았다.
                            let person = {이름: name, 나이: age}
                        바뀐 방법으로 만들면 다음과 같다.
                            let person = {name, age}

        </textarea>
        <script>
            /* function foo() {
                console.log('곰돌이 푸우');
            } */
            // => function 대체
            /* let foo = () => {
                console.log('곰돌이 푸우');
            };
            foo(); */
            /* let foo = () => '푸우는 꿀을 좋아행~';
            console.log(foo());
            let age = 30;
            let person = {
                name: '김성진',
                age: 20,
                getInfo: function () {
                    console.log(age);
                },
            };
            person.getInfo(); */
            // let age = 30;
            // let person = {
            //     name: '김성진',
            //     age: 20,
            //     getInfo: function () {
            //         console.log(this);
            //     },
            // };
            // person.getInfo();
            let 이름 = 'SungJin';
            let 나이 = 20;
            let person = { 이름, 나이 };
            console.log(person);
        </script>
    </body>
</html>
